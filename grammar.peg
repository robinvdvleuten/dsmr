package dsmr

import "time"

type parser Peg {
    t *Telegram
    o *OBIS
    c *COSEM
    a Attribute
    tz *time.Location
}

Telegram <- 
    Header 
    COSEM+
    Footer 
    EOF

Header 
    <- < '/' ( !EOL . )+ > EOL+ { p.t.header = text }

COSEM 
    <- OBIS { p.c = &COSEM{obis: p.o}; p.a = nil }
    Attribute+ { p.t.cosem[p.c.obis.value] = p.c }

Footer 
    <- '!' < ( !EOL . )* > EOL { p.t.checksum = text }

OBIS 
    <- < Number '-' Number ':' Number '.' Number '.' Number > { p.o = &OBIS{value: text} }

Attribute 
    <- '(' ( Measurement / Timestamp / Text )* ')' EOL?
    {
        if p.a != nil {
            p.c.attribute = append(p.c.attribute, p.a)
        }
    }

Measurement 
    <- < ( Number / '.' )+ > '*' { n, _ := strconv.ParseFloat(text, 32); p.a = &Measurement{value: n} }
    < ( !')' . )+ > { p.a.(*Measurement).unit = text }

Text 
    <- < ( !')' . )+ > { p.a = &Text{value: text} }

Timestamp 
    <- < Number > ( 'S' / 'W' ) { t, _ := time.ParseInLocation("060102150405", text, p.tz); p.a = &Timestamp{value: t.UTC()} }

Number 
    <- [0-9]+

EOL 
    <- '\r\n'

EOF 
    <- !.
